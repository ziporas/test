    "diff": "--- a/swagger-doc/swagger.json\n+++ b/swagger-doc/swagger.json\n@@ -1,3 +1,7599 @@\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n \n {\n   \"swagger\": \"2.0\","
    "diff": "--- a/swagger-doc/swagger.json\n+++ b/swagger-doc/swagger.json\n@@ -1,3 +1,7599 @@\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n \n {\n   \"swagger\": \"2.0\","
    "diff": "--- a/swagger-doc/swagger.json\n+++ b/swagger-doc/swagger.json\n@@ -1,3 +1,7599 @@\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n \n {\n   \"swagger\": \"2.0\","
    "diff": "--- a/swagger-doc/swagger.json\n+++ b/swagger-doc/swagger.json\n@@ -1,3 +1,7599 @@\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n \n {\n   \"swagger\": \"2.0\","
    "diff": "--- a/swagger-doc/swagger.json\n+++ b/swagger-doc/swagger.json\n@@ -1,3 +1,7599 @@\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n+# == Schema Information\n+#\n+# Table name: projects\n+#\n+#  id                     :integer          not null, primary key\n+#  name                   :string(255)\n+#  path                   :string(255)\n+#  description            :text\n+#  created_at             :datetime\n+#  updated_at             :datetime\n+#  creator_id             :integer\n+#  issues_enabled         :boolean          default(TRUE), not null\n+#  wall_enabled           :boolean          default(TRUE), not null\n+#  merge_requests_enabled :boolean          default(TRUE), not null\n+#  wiki_enabled           :boolean          default(TRUE), not null\n+#  namespace_id           :integer\n+#  issues_tracker         :string(255)      default(\"gitlab\"), not null\n+#  issues_tracker_id      :string(255)\n+#  snippets_enabled       :boolean          default(TRUE), not null\n+#  last_activity_at       :datetime\n+#  import_url             :string(255)\n+#  visibility_level       :integer          default(0), not null\n+#  archived               :boolean          default(FALSE), not null\n+#  import_status          :string(255)\n+#  star_count             :integer\n+#breeze++\n+#  avatar                 :string(255)\n+#breeze+\n+\n+class Project < ActiveRecord::Base\n+  ActiveRecord::Base.establish_connection ENV['env']\n+  include FlowEditor\n+  include Gitlab::ShellAdapter\n+  include Gitlab::VisibilityLevel\n+  include Gitlab::ConfigHelper\n+  extend Gitlab::ConfigHelper\n+  extend Enumerize\n+  include BreezeUtil\n+\n+  default_value_for :archived, false\n+  default_value_for :visibility_level, gitlab_config_features.visibility_level\n+  default_value_for :issues_enabled, gitlab_config_features.issues\n+  default_value_for :merge_requests_enabled, gitlab_config_features.merge_requests\n+  default_value_for :wiki_enabled, gitlab_config_features.wiki\n+  default_value_for :wall_enabled, false\n+  default_value_for :snippets_enabled, gitlab_config_features.snippets\n+\n+  ActsAsTaggableOn.strict_case_match = true\n+\n+  acts_as_taggable_on :labels, :issues_default_labels\n+\n+  attr_accessor :new_default_branch, :new_display_name\n+  \n+  # Relations\n+  belongs_to :creator,      foreign_key: \"creator_id\", class_name: \"User\"\n+  belongs_to :group, -> { where(type: Group) }, foreign_key: \"namespace_id\"\n+  belongs_to :namespace\n+\n+  has_one :last_event, -> {order 'events.created_at DESC'}, class_name: 'Event', foreign_key: 'project_id'\n+  # Project services\n+  has_many :services\n+  has_many :labels\n+  has_one :gitlab_ci_service, dependent: :destroy\n+  has_one :campfire_service, dependent: :destroy\n+  has_one :emails_on_push_service, dependent: :destroy\n+  has_one :pivotaltracker_service, dependent: :destroy\n+  has_one :hipchat_service, dependent: :destroy\n+  has_one :flowdock_service, dependent: :destroy\n+  has_one :assembla_service, dependent: :destroy\n+  has_one :gemnasium_service, dependent: :destroy\n+  has_one :slack_service, dependent: :destroy\n+  has_one :forked_project_link, dependent: :destroy, foreign_key: \"forked_to_project_id\"\n+  has_one :forked_from_project, through: :forked_project_link\n+  # Merge Requests for target project should be removed with it\n+  has_many :merge_requests,     dependent: :destroy, foreign_key: \"target_project_id\"\n+  # Merge requests from source project should be kept when source project was removed\n+  has_many :fork_merge_requests, foreign_key: \"source_project_id\", class_name: MergeRequest\n+  has_many :issues, -> { order \"state DESC, created_at DESC\" }, dependent: :destroy\n+  \n+  has_many :services,           dependent: :destroy\n+  has_many :events,             dependent: :destroy\n+  has_many :milestones,         dependent: :destroy\n+  has_many :notes,              dependent: :destroy\n+  has_many :snippets,           dependent: :destroy, class_name: \"ProjectSnippet\"\n+  has_many :hooks,              dependent: :destroy, class_name: \"ProjectHook\"\n+  has_many :protected_branches, dependent: :destroy\n+  has_many :users_projects, dependent: :destroy\n+  has_many :users, through: :users_projects\n+  has_many :deploy_keys_projects, dependent: :destroy\n+  has_many :deploy_keys, through: :deploy_keys_projects\n+  has_many :users_star_projects, dependent: :destroy\n+  has_many :starrers, through: :users_star_projects, source: :user\n+\n+  delegate :name, to: :owner, allow_nil: true, prefix: true\n+  delegate :members, to: :team, prefix: true\n+\n+  # Validations\n+  validates :creator, presence: true, on: :create\n+  validates :description, length: { maximum: 2000 }, allow_blank: true,\n+            format: { with: Gitlab::Regex.description_regex,\n+                      message: Gitlab::Regex.description_regex_message }\n+  validates :name, presence: true, length: { within: 0..100 },\n+            format: { with: Gitlab::Regex.project_name_regex,\n+                      message: Gitlab::Regex.project_regex_message }\n+  validates :path, presence: true, length: { within: 0..255 },\n+            exclusion: { in: Gitlab::Blacklist.path },\n+            format: { with: Gitlab::Regex.path_regex,\n+                      message: Gitlab::Regex.path_regex_message }\n+  validates :issues_enabled, :merge_requests_enabled,\n+            :wiki_enabled, inclusion: { in: [true, false] }\n+  validates :visibility_level,\n+    exclusion: { in: gitlab_config.restricted_visibility_levels },\n+    if: -> { gitlab_config.restricted_visibility_levels.any? }\n+  validates :issues_tracker_id, length: { maximum: 255 }, allow_blank: true\n+  validates :namespace, presence: true\n+  validates_uniqueness_of :name, scope: :namespace_id\n+  validates_uniqueness_of :path, scope: :namespace_id\n+  # validates :import_url,\n+  #   format: { with: URI::regexp(%w(git http https)), message: \"should be a valid url\" },\n+  #   if: :import?\n+  validates :star_count, numericality: { greater_than_or_equal_to: 0 }\n+  # validate :check_limit, on: :create\n+  #breeze++\n+  validate :avatar_type,\n+    if: ->(project) { !project.avatar.blank? && project.avatar_changed? }\n+  validates :avatar, file_size: { maximum: 100.kilobytes.to_i }\n+  validate :is_cloud_valid?\n+  \n+  before_create :generate_encryption_key\n+  before_validation :set_default_cloud, on: :create\n+\n+  before_destroy :destroy_depended_objects\n+\n+  mount_uploader :avatar, AttachmentUploader\n+  #breeze+\n+  # Scopes\n+  scope :without_user, ->(user)  { where(\"projects.id NOT IN (:ids)\", ids: user.authorized_projects.map(&:id) ) }\n+  scope :without_team, ->(team) { team.projects.present? ? where(\"projects.id NOT IN (:ids)\", ids: team.projects.map(&:id)) : scoped  }\n+  scope :not_in_group, ->(group) { where(\"projects.id NOT IN (:ids)\", ids: group.project_ids ) }\n+  scope :in_team, ->(team) { where(\"projects.id IN (:ids)\", ids: team.projects.map(&:id)) }\n+  scope :in_namespace, ->(namespace) { where(namespace_id: namespace.id) }\n+  scope :in_group_namespace, -> { joins(:group) }\n+  scope :sorted_by_activity, -> { reorder(\"projects.last_activity_at DESC\") }\n+  scope :personal, ->(user) { where(namespace_id: user.namespace_id) }\n+  scope :joined, ->(user) { where(\"namespace_id != ?\", user.namespace_id) }\n+  scope :public_only, -> { where(visibility_level: Project::PUBLIC) }\n+  scope :public_and_internal_only, -> { where(visibility_level: Project.public_and_internal_levels) }\n+  scope :non_archived, -> { where(archived: false) }\n+\n+  enumerize :issues_tracker, in: (Gitlab.config.issues_tracker.keys).append(:gitlab), default: :gitlab\n+\n+  \n+  state_machine :import_status, initial: :none do\n+    event :import_start do\n+      transition none: :started\n+    end\n+\n+    event :import_finish do\n+      transition [:none, :started] => :finished\n+    end\n+    \n+    event :import_fail do\n+      transition any => :failed\n+    end\n+\n+    event :import_retry do\n+      transition failed: :started\n+    end\n+\n+    state :started\n+    state :finished\n+    state :failed\n+\n+    after_transition any => :started do |project, transition|\n+      Rails.logger.info 'Create-Project: Import repository starting for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+      RepositoryImportWorker.perform_async(project.id, project.path_with_namespace, project.import_url)\n+    end\n+\n+    after_transition any => :finished do |project, transition|\n+      project.save\n+      project.satellite.create unless project.satellite.exists?\n+      project.update_repository_size\n+      project.create_default_environments\n+      \n+      Rails.logger.info 'Create-Project: Repository is successfuly imported for project: id [%s], [%s], import_status [%s]' % [project.id, project.path_with_namespace, project.import_status]\n+    end\n+  \n+  end\n+\n+  def create_default_environments\n+    rules_settings = FlowPortal::config.environment.rules\n+\n+    [rules_settings['dev_environment'], rules_settings['prod_environment']].each do |environment_name|\n+      environment_params = {\n+          name: environment_name,\n+          description: rules_settings['environment_description'],\n+          branch: environment_name\n+      }\n+\n+      Rails.logger.info \"Creating #{environment_name} with params - environment_params: %s\" % environment_params.to_json\n+      ::Environments::CreateService.new(self.creator,self, environment_params).execute\n+    end\n+  end\n+ \n+  def generate_encryption_key\n+    self.encryption_key =  SecureRandom.hex(16)\n+  end\n+\n+  def set_default_cloud\n+    self.cloud_id = Cloud.runtime.default.id unless cloud_id\n+  end\n+\n+  # find the (active) spaces (in mysql) of the current project\n+  def spaces(all=false)\n+    if all\n+      Space.where({:project_id => self.id}).entries\n+    else\n+      Space.where({:project_id => self.id}).entries.select{|s| s.deleted_at.nil?}\n+    end\n+  end\n+\n+  # find the environment (in mysql) of the current project\n+  def environments\n+    Environment.where({:project_id => self.id}).entries\n+  end\n+\n+  def default_environment\n+    self.environments.detect{|env| env.is_default?}\n+  end\n+\n+  # delete the depended objects in flowdesigner database\n+  def destroy_depended_objects\n+    self.spaces.each { |s| s.destroy }\n+    self.environments.each { |s| s.destroy }\n+    self.labels.each { |l| l.destroy }\n+  end\n+\n+  # stop project runtime defaul flow \n+  def delete_default_space\n+    self.default_space.destroy! \n+  end\n+\n+  def default_space\n+    @default_space = self.spaces(true).detect{|s| s.is_default}\n+  end\n+\n+  def running_spaces\n+    self.spaces.select{ |s| s.flow_is_running? \"flow\" }\n+  end\n+\n+  def released_spaces\n+    self.spaces.select{ |s| !s.end_points.nil? && !s.end_points.empty? && !s.is_default}\n+  end\n+\n+  def find_label commit_sha\n+    self.labels.find_by_commit_sha(commit_sha)\n+  end\n+\n+  def cloud\n+    if namespace\n+      namespace.clouds.find(cloud_id) \n+    end\n+  end\n+\n+  def is_cloud_valid?\n+    unless cloud\n+       errors.add(:cloud_id, \"is not valid\")\n+    end\n+  end\n+\n+  class << self\n+    def public_and_internal_levels\n+      [Project::PUBLIC]\n+    end\n+\n+    def abandoned\n+      where('projects.last_activity_at < ?', 6.months.ago)\n+    end\n+\n+    def publicish(user)\n+      visibility_levels = [Project::PUBLIC]\n+      \n+    end\n+\n+    def with_push\n+      includes(:events).where('events.action = ?', Event::PUSHED)\n+    end\n+\n+    def active\n+      joins(:issues, :notes, :merge_requests).order(\"issues.created_at, notes.created_at, merge_requests.created_at DESC\")\n+    end\n+\n+    def search query\n+      joins(:namespace).where(\"projects.archived = ?\", false).where(\"projects.name LIKE :query OR projects.path LIKE :query OR projects.description LIKE :query\", query: \"%#{query}%\")\n+    end\n+\n+    def search_by_title query\n+      where(\"projects.archived = ?\", false).where(\"LOWER(projects.name) LIKE :query\", query: \"%#{query.downcase}%\")\n+    end\n+\n+    def find_with_namespace(id)\n+      return nil unless id\n+      return nil unless id.include?(\"/\")\n+\n+      id = id.split(\"/\")\n+      namespace = Namespace.find_by(path: id.first)\n+      return nil unless namespace\n+\n+      where(namespace_id: namespace.id).find_by(path: id.second)\n+    end\n+\n+    def visibility_levels\n+      Gitlab::VisibilityLevel.options\n+    end\n+\n+    def sort(method,direction = nil)\n+      case method.to_s\n+      when 'name' then reorder('projects.name ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'newest' then reorder('projects.created_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'oldest' then reorder('projects.created_at ' + (direction.nil?  ? \"ASC\" : direction))\n+      when 'recently_updated' then reorder('projects.updated_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'last_updated', 'last_activity' then reorder('projects.last_activity_at ' + (direction.nil?  ? \"DESC\" : direction))\n+      when 'largest_repository' then reorder('projects.repository_size ' + (direction.nil?  ? \"DESC\" : direction))\n+      else reorder(\"projects.name \" + (direction.nil?  ? \"ASC\" : direction))\n+      end\n+    end\n+\n+    def normilize_path name\n+      path = name.dup.parameterize\n+      while path.gsub!(/-{2,}+|(_-_)|(_-)|(-_)/,'-')\n+      end\n+      path\n+    end\n+  end\n+\n+  def team\n+    @team ||= ProjectTeam.new(self)\n+  end\n+\n+  def repository\n+    @repository ||= Repository.new(path_with_namespace)\n+  end\n+\n+  def reset_repository\n+    @repository = Repository.new(path_with_namespace)\n+  end\n+\n+  def saved?\n+    id && persisted?\n+  end\n+  \n+  def import?\n+    import_url.present?\n+  end\n+\n+  def imported?\n+    import_finished?\n+  end\n+\n+  def import_in_progress?\n+    import? && import_status == 'started'\n+  end\n+\n+  def import_failed?\n+    import_status == 'failed'\n+  end\n+\n+  def import_finished?\n+    import_status == 'finished'\n+  end\n+\n+  def check_limit\n+    non_deleted_projs = creator.non_deleted_projs\n+    #unless creator.can_create_project? or namespace.kind == 'group'\n+    if !creator.can_create_project?\n+      if creator.non_del_projects_limit_left > 0\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Old projects deletion might still be in progress. Please try again later or contact your administrator.\")\n+      else\n+        errors[:limit_reached] << (\": Your project limit is #{creator.projects_limit} projects! Please contact your administrator to increase it\")\n+      end\n+    end\n+  rescue\n+    errors[:base] << (\"Can't check your ability to create project\")\n+  end\n+\n+  def to_param\n+    namespace.path + \"/\" + path\n+  end\n+\n+  def web_url\n+    [gitlab_config.url, path_with_namespace].join(\"/\")\n+  end\n+\n+  def web_url_without_protocol\n+    web_url.split(\"://\")[1]\n+  end\n+\n+  def build_commit_note(commit)\n+    notes.new(commit_id: commit.id, noteable_type: \"Commit\")\n+  end\n+\n+  def last_activity\n+    last_event\n+  end\n+\n+  def last_activity_date\n+    last_activity_at || updated_at\n+  end\n+\n+  def project_id\n+    self.id\n+  end\n+\n+  # Tags are shared by issues and merge requests\n+  def issues_labels\n+    @issues_labels ||= (issues_default_labels +\n+                        merge_requests.tags_on(:labels) +\n+                        issues.tags_on(:labels)).uniq.sort_by(&:name)\n+  end\n+\n+  def issue_exists?(issue_id)\n+    if used_default_issues_tracker?\n+      self.issues.where(iid: issue_id).first.present?\n+    else\n+      true\n+    end\n+  end\n+\n+  def used_default_issues_tracker?\n+    self.issues_tracker == Project.issues_tracker.default_value\n+  end\n+\n+  def can_have_issues_tracker_id?\n+    self.issues_enabled && !self.used_default_issues_tracker?\n+  end\n+\n+  def build_missing_services\n+    available_services_names.each do |service_name|\n+      service = services.find { |service| service.to_param == service_name }\n+\n+      # If service is available but missing in db\n+      # we should create an instance. Ex `create_gitlab_ci_service`\n+      service = self.send :\"create_#{service_name}_service\" if service.nil?\n+    end\n+  end\n+\n+  def available_services_names\n+    %w(gitlab_ci campfire hipchat pivotaltracker flowdock assembla emails_on_push gemnasium slack)\n+  end\n+\n+  def gitlab_ci?\n+    gitlab_ci_service && gitlab_ci_service.active\n+  end\n+\n+  def ci_services\n+    services.select { |service| service.category == :ci }\n+  end\n+\n+  def ci_service\n+    @ci_service ||= ci_services.select(&:activated?).first\n+  end\n+\n+  #breeze++\n+  def avatar_type\n+    unless avatar.image?\n+      errors.add :avatar, 'only images allowed'\n+    end\n+  end\n+\n+  def avatar_in_git\n+    @avatar_file ||= 'logo.png' if repository.blob_at_branch('master', 'logo.png')\n+    @avatar_file ||= 'logo.jpg' if repository.blob_at_branch('master', 'logo.jpg')\n+    @avatar_file ||= 'logo.gif' if repository.blob_at_branch('master', 'logo.gif')\n+    @avatar_file\n+  end\n+  #breeze+\n+  # For compatibility with old code\n+  def code\n+    path\n+  end\n+\n+  def items_for entity\n+    case entity\n+    when 'issue' then\n+      issues\n+    when 'merge_request' then\n+      merge_requests\n+    end\n+  end\n+\n+  def send_move_instructions\n+    NotificationService.new.project_was_moved(self)\n+  end\n+\n+  def owner\n+    if group\n+      group\n+    else\n+      namespace.try(:owner)\n+    end\n+  end\n+\n+  def account\n+    return self.namespace.owner.role;\n+  end\n+\n+  def team_member_by_name_or_email(name = nil, email = nil)\n+    user = users.where(\"name like ? or email like ?\", name, email).first\n+    users_projects.where(user: user) if user\n+  end\n+\n+  # Get Team Member record by user id\n+  def team_member_by_id(user_id)\n+    users_projects.find_by(user_id: user_id)\n+  end \n+\n+  def name_with_namespace\n+    @name_with_namespace ||= begin\n+                               if namespace\n+                                 namespace.human_name + \" / \" + name\n+                               else\n+                                 name\n+                               end\n+                             end\n+  end\n+\n+  def path_with_namespace\n+    if namespace\n+      namespace.path + '/' + path\n+    else\n+      path\n+    end\n+  end\n+\n+  def project_name_with_namespace\n+    if namespace\n+      namespace.name + '/' + name\n+    else\n+      name\n+    end\n+  end\n+\n+  def project_namespace\n+    \"#{path}.#{namespace.path}\".downcase\n+  end  \n+\n+  def execute_hooks(data, hooks_scope = :push_hooks)\n+    hooks.send(hooks_scope).each do |hook|\n+      hook.async_execute(data)\n+    end\n+  end\n+\n+  def execute_services(data)\n+    services.each do |service|\n+\n+      # Call service hook only if it is active\n+      begin\n+        service.execute(data) if service.active\n+      rescue => e\n+        logger.error(e)\n+      end\n+    end\n+  end\n+\n+  def update_merge_requests(oldrev, newrev, ref, user)\n+    return true unless ref =~ /heads/\n+    branch_name = ref.gsub(\"refs/heads/\", \"\")\n+    c_ids = self.repository.commits_between(oldrev, newrev).map(&:id)\n+\n+    # Close merge requests\n+    mrs = self.merge_requests.opened.where(target_branch: branch_name).to_a\n+    mrs = mrs.select(&:last_commit).select { |mr| c_ids.include?(mr.last_commit.id) }\n+    mrs.each { |merge_request| MergeRequests::MergeService.new.execute(merge_request, user, nil) }\n+\n+    # Update code for merge requests into project between project branches\n+    mrs = self.merge_requests.opened.by_branch(branch_name).to_a\n+    # Update code for merge requests between project and project fork\n+    mrs += self.fork_merge_requests.opened.by_branch(branch_name).to_a\n+    mrs.each { |merge_request| merge_request.reload_code; merge_request.mark_as_unchecked }\n+\n+    true\n+  end\n+\n+  def valid_repo?\n+    repository.exists?\n+  rescue\n+    errors.add(:path, \"Invalid repository path\")\n+    false\n+  end\n+\n+  def empty_repo?\n+    !repository.exists? || repository.empty?\n+  end\n+\n+  def ensure_satellite_exists\n+    self.satellite.create unless self.satellite.exists?\n+  end\n+\n+  def satellite\n+    @satellite ||= Gitlab::Satellite::Satellite.new(self)\n+  end\n+\n+  def repo\n+    repository.raw\n+  end\n+\n+  def url_to_repo\n+    gitlab_shell.url_to_repo(path_with_namespace)\n+  end\n+\n+  def namespace_dir\n+    namespace.try(:path) || ''\n+  end\n+\n+  def repo_exists?\n+    @repo_exists ||= repository.exists?\n+  rescue\n+    @repo_exists = false\n+  end\n+\n+  def open_branches\n+    all_branches = repository.branches\n+\n+    if protected_branches.present?\n+      all_branches.reject! do |branch|\n+        protected_branches_names.include?(branch.name)\n+      end\n+    end\n+\n+    all_branches\n+  end\n+\n+  def protected_branches_names\n+    @protected_branches_names ||= protected_branches.map(&:name)\n+  end\n+\n+  def root_ref?(branch)\n+    repository.root_ref == branch\n+  end\n+\n+  def ssh_url_to_repo\n+    url_to_repo\n+  end\n+\n+  def http_url_to_repo\n+    [gitlab_config.url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def http_internal_url_to_repo\n+    [gitlab_config.internal_url, \"/\", path_with_namespace, \".git\"].join('')\n+  end\n+\n+  def uri_to_repo\n+    [path_with_namespace, \".git\"].join('')\n+  end\n+\n+  # Check if current branch name is marked as protected in the system\n+  def protected_branch? branch_name\n+    protected_branches_names.include?(branch_name)\n+  end\n+\n+  def forked?\n+    !(forked_project_link.nil? || forked_project_link.forked_from_project.nil?)\n+  end\n+\n+  def personal?\n+    !group\n+  end\n+\n+  def rename_repo\n+    old_path_with_namespace = File.join(namespace_dir, path_was)\n+    new_path_with_namespace = File.join(namespace_dir, path)\n+\n+    if gitlab_shell.mv_repository(old_path_with_namespace, new_path_with_namespace)\n+      # If repository moved successfully we need to remove old satellite\n+      # and send update instructions to users.\n+      # However we cannot allow rollback since we moved repository\n+      # So we basically we mute exceptions in next actions\n+      begin\n+        gitlab_shell.mv_repository(\"#{old_path_with_namespace}.wiki\", \"#{new_path_with_namespace}.wiki\")\n+        gitlab_shell.rm_satellites(old_path_with_namespace)\n+        ensure_satellite_exists\n+        send_move_instructions\n+        reset_events_cache\n+      rescue\n+        # Returning false does not rollback after_* transaction but gives\n+        # us information about failing some of tasks\n+        false\n+      end\n+    else\n+      # if we cannot move namespace directory we should rollback\n+      # db changes in order to prevent out of sync between db and fs\n+      raise Exception.new('repository cannot be renamed')\n+    end\n+  end\n+\n+  # Reset events cache related to this project\n+  #\n+  # Since we do cache @event we need to reset cache in special cases:\n+  # * when project was moved\n+  # * when project was renamed\n+  #breeze++\n+  # * when the project avatar changes\n+  #breeze+\n+  # Events cache stored like  events/23-20130109142513.\n+  # The cache key includes updated_at timestamp.\n+  # Thus it will automatically generate a new fragment\n+  # when the event is updated because the key changes.\n+  def reset_events_cache\n+    Event.where(project_id: self.id).\n+      order('id DESC').limit(100).\n+      update_all(updated_at: Time.now)\n+  end\n+\n+  def project_member(user)\n+    users_projects.where(user_id: user).first\n+  end\n+\n+  def default_branch\n+    @default_branch ||= repository.root_ref if repository.exists?\n+  end\n+\n+  def reload_default_branch\n+    @default_branch = nil\n+    default_branch\n+  end\n+\n+  def visibility_level_field\n+    visibility_level\n+  end\n+\n+  def archive!\n+    update_attribute(:archived, true)\n+  end\n+\n+  def unarchive!\n+    update_attribute(:archived, false)\n+  end\n+\n+  def change_head(branch)\n+    gitlab_shell.update_repository_head(self.path_with_namespace, branch)\n+    reload_default_branch\n+  end\n+\n+  def forked_from?(project)\n+    forked? && project == forked_from_project\n+  end\n+\n+  def update_repository_size\n+    update_attribute(:repository_size, repository.size)\n+  end\n+\n+  def forks_count\n+    ForkedProjectLink.where(forked_from_project_id: self.id).count\n+  end\n+\n+  def set_path\n+   self.path = Project.normilize_path(self.name)\n+  end\n+\n+  def self.creator_project(creator_id)\n+    Project.where({:creator_id => creator_id}).size\n+  end\n+\n+  def self.sort_projects(projects)\n+    projects.each do |project|\n+      if project.namespace.class.name == \"Group\"\n+        project.new_display_name = project.project_name_with_namespace.downcase\n+      else\n+        project.new_display_name = project.name.downcase\n+      end\n+    end\n+    projects = projects.sort_by &:updated_at\n+    projects.reverse!\n+  end\n+\n+  def editor_details\n+      details = nil\n+      user_projects = EditingFile.current_editing_projects || []\n+      projects = user_projects.map{|i|i[1]}\n+      project_index = projects.index(self.id.to_s)\n+      if project_index\n+          user = User.find(user_projects[project_index][0])\n+        if user\n+            details = {\n+              :name => user.name,\n+              :email => user.email,\n+              :avatar_url => user.get_avatar_icon()\n+            }\n+        end  \n+      end\n+      details \n+  end\n+\n+  # to run over when request if from portal-ui (when data[:params] exists)\n+  def as_json(data = {})\n+\n+    options = if data.presence && data[:options].presence then data[:options] else {} end\n+\n+    h = super(options)\n+    \n+    if data.presence && data[:params].presence\n+      params = data[:params]\n+      user = params[:current_user]      \n+      project = self\n+\n+      h[:meta] = {\n+        :is_empty_repo => ProjectUtil.empty_repo?(project),\n+        :visibility_level_name => ProjectUtil.visibility_level_name(project),\n+        :flows_number => ProjectUtil.flows_number(project),\n+        :user_role_in_project => ProjectUtil.user_role_in_project(user, project),\n+        :can_user_remove_project => ProjectUtil.can_user_remove_project(user, project),\n+        :group => ProjectUtil.group(project),\n+        :name_with_namespace => ProjectUtil.name_with_namespace(project),\n+        :path_with_namespace => ProjectUtil.path_with_namespace(project),\n+        :editing_user_details => ProjectUtil.editing_user_details(project)\n+      }\n+    end\n+\n+    h\n+\n+  end \n+\n+  def add_grm_params\n+    grm_params = {}\n+    grm_params[:namespace] = self.namespace.path\n+    grm_params[:project] = self.path\n+    grm_params[:flowEnvironment] = {}\n+    grm_params[:organization] = self.organization if self.organization\n+    grm_params\n+  end\n+\n+  def grm_services_status\n+    grm_params = self.add_grm_params\n+    self.spaces.each do |space|\n+      grm_params[:flowEnvironment][space.name] = space.add_grm_params('service_status')\n+    end\n+    statuses = GrmRegistar::get_services_status(grm_params)\n+    Rails.logger.info \"Grm services status: #{statuses}, project: #{self.path}\"\n+    statuses\n+  end\n+\n+\n+end\n \n {\n   \"swagger\": \"2.0\","







































































































































































































































































































































































































